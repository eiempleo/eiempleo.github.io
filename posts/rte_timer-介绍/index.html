<!DOCTYPE html>











<html lang="en-us">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>rte_timer 介绍 - Mercury</title>

  
  
  <meta name="description" content="https://doc.dpdk.org/guides/prog_guide/timer_lib.html
timer lib 特性，  Timers can be periodic (multi-shot) or single (one-shot).  可以在一个 lcore 加载， 另一个 lcore 执行， 通过 rte_timer_reset() 指定，
2. Timers can be loaded from one core and executed on another. It has to be specified in the call to rte_timer_reset().
可通过调用 rte_timer_manage() 的频率 提高 timer 的精度，
3. Timers provide high precision (depends on the call frequency to rte_timer_manage() that checks timer expiration for the local core)." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://eiempleo.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://eiempleo.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://eiempleo.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://eiempleo.github.io/theme.png" />

  

  
  <link rel="icon" href="https://eiempleo.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://eiempleo.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.99.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="rte_timer 介绍" />
<meta property="og:description" content="https://doc.dpdk.org/guides/prog_guide/timer_lib.html
timer lib 特性，  Timers can be periodic (multi-shot) or single (one-shot).  可以在一个 lcore 加载， 另一个 lcore 执行， 通过 rte_timer_reset() 指定，
2. Timers can be loaded from one core and executed on another. It has to be specified in the call to rte_timer_reset().
可通过调用 rte_timer_manage() 的频率 提高 timer 的精度，
3. Timers provide high precision (depends on the call frequency to rte_timer_manage() that checks timer expiration for the local core)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eiempleo.github.io/posts/rte_timer-%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-25T09:00:00+08:00" />
<meta property="article:modified_time" content="2022-01-25T09:00:00+08:00" />


  
  <meta itemprop="name" content="rte_timer 介绍">
<meta itemprop="description" content="https://doc.dpdk.org/guides/prog_guide/timer_lib.html
timer lib 特性，  Timers can be periodic (multi-shot) or single (one-shot).  可以在一个 lcore 加载， 另一个 lcore 执行， 通过 rte_timer_reset() 指定，
2. Timers can be loaded from one core and executed on another. It has to be specified in the call to rte_timer_reset().
可通过调用 rte_timer_manage() 的频率 提高 timer 的精度，
3. Timers provide high precision (depends on the call frequency to rte_timer_manage() that checks timer expiration for the local core)."><meta itemprop="datePublished" content="2022-01-25T09:00:00+08:00" />
<meta itemprop="dateModified" content="2022-01-25T09:00:00+08:00" />
<meta itemprop="wordCount" content="697">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="rte_timer 介绍"/>
<meta name="twitter:description" content="https://doc.dpdk.org/guides/prog_guide/timer_lib.html
timer lib 特性，  Timers can be periodic (multi-shot) or single (one-shot).  可以在一个 lcore 加载， 另一个 lcore 执行， 通过 rte_timer_reset() 指定，
2. Timers can be loaded from one core and executed on another. It has to be specified in the call to rte_timer_reset().
可通过调用 rte_timer_manage() 的频率 提高 timer 的精度，
3. Timers provide high precision (depends on the call frequency to rte_timer_manage() that checks timer expiration for the local core)."/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://eiempleo.github.io/">Mercury</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>Jan 25, 2022</time>
      
      
    </p>
    <h1>rte_timer 介绍</h1>
  </header>
  <section class="post-content"><p><a href="https://doc.dpdk.org/guides/prog_guide/timer_lib.html">https://doc.dpdk.org/guides/prog_guide/timer_lib.html</a></p>
<h2 id="timer-lib-特性">timer lib 特性，</h2>
<ol>
<li>Timers can be periodic (multi-shot) or single (one-shot).</li>
</ol>
<p>可以在一个 lcore 加载， 另一个 lcore 执行， 通过 rte_timer_reset() 指定，<br>
2. Timers can be loaded from one core and executed on another. It has to be specified in the call to rte_timer_reset().</p>
<p>可通过调用 rte_timer_manage() 的频率 提高 timer 的精度，<br>
3. Timers provide high precision (depends on the call frequency to rte_timer_manage() that checks timer expiration for the local core).</p>
<ol start="4">
<li>
<p>If not required in the application, timers can be disabled at compilation time by not calling the rte_timer_manage() to increase performance.</p>
</li>
<li>
<p>The timer library uses the rte_get_timer_cycles() function that uses the High Precision Event Timer (HPET) or the CPUs Time Stamp Counter (TSC) to provide a reliable time reference.</p>
</li>
</ol>
<h2 id="timer-状态">timer 状态</h2>
<p>下面的 owner 是 lcore ，</p>
<p>RTE_TIMER_PENDING<br>
等待执行， 具有所有者， 也就是添加到 skiplist 里， 但还未超时的 timer ，<br>
rte_timer_reset().rte_timer_alt_reset().__rte_timer_reset()<br>
RTE_TIMER_RUNNING<br>
owned by a core, must not be modified by another core, present in a list<br>
正在执行， 具有所有者， 也就是 即将执行 timer callback ，<br>
rte_timer_manage() 里可以看出，<br>
RTE_TIMER_STOP:<br>
no owner, not in a list<br>
停止状态， 没有 所有者， 没有添加到 skiplist 里，</p>
<h2 id="关于-timer_data_id">关于 timer_data_id</h2>
<p>主要用于在 rte_timer_data_arr[] 数组里 找到 对应的 timer_data ，<br>
timer_data = rte_timer_data_arr[timer_data_id]</p>
<p>rte_timer_data_arr 数组 中的 每个成员都是一个 rte_timer_data 结构，</p>
<pre tabindex="0"><code>struct rte_timer_data {  
	struct priv_timer priv_timer[RTE_MAX_LCORE];  
	uint8_t internal_flags;  
}; 
</code></pre><p>这个结构相当于定义了 RTE_MAX_LCORE 个 priv_timer ，<br>
每个 priv_timer 对应一个 skip list (不过有些 skip list 可能不存在数据)，</p>
<p>rte_timer_reset() 和 rte_timer_manage() 默认都使用 default_data_id ，<br>
如果想要使用其他 timer_data_id ，需要使用 rte_timer_alt_reset() 或 rte_timer_alt_manage() 来指定，</p>
<p>__rte_timer_reset() 添加 timer 或 rte_timer_alt_manage() 检查超时 timer 时，<br>
都需要根据 timer_data_id 和 lcore_id 找到对应的 skip list ，</p>
<p>default_data_id 为 static 全局变量， 为 0 ，</p>
<h2 id="关于-skip-list-">关于 skip list ，</h2>
<p>存在 timer_data_id * RTE_MAX_LCORE 个 skip list ，<br>
不过 大多数 skip list 不存在数据，<br>
通常只有 default_data_id 里部分 lcore 对应的 skip list 存在数据，</p>
<p>插入 和 查询的算法和 skip list 一致，<br>
只不过只会操作对应的 skip list ，(通过 timer_data_id 和 lcore id 来确定)<br>
rte_timer_reset() 和 rte_timer_manage() 的实现里可以看到，<br>
比如 rte_timer_reset() 添加到了 timer_data_id == 0 &amp;&amp; lcore_id == 1 对应的 skip list 中，<br>
如果 rte_timer_manage() 检查的是 timer_data_id == 0 &amp;&amp; lcore_id == 0 对应的 skip list ，则 刚刚添加的 timer 永远不会触发，</p>
<p>需要通过 rte_timer_stop() 、 rte_timer_reset() 等 dpdk timer 接口来删除 rte_timer ，<br>
不能直接 memset(0) ， 会导致 skip list 链表断裂，<br>
rte_timer_manage() 遍历时会操作到未知数据，<br>
rte_timer_reset() 添加 timer 查找 skiplist 可用位置时可能也会出错，<br>
比如下面 g_cndb 的 aging_timer 为 rte_timer ，一般可能不会去 memset 直接释放 rte_timer ，<br>
但可能 直接 memset 释放 g_cndb ，造成 rte_timer 一起被清空， 导致 dpdk timer 的 skip list 异常断裂，</p>
<pre tabindex="0"><code>(gdb) p *g_cndb  
$54 = {cfg = {ccn_capacity = 1000000, chunk_size = 2097152, chunk_num = 142, hash_mask = 524287, aging_cyc = 33900000, aging_num = 2048}, htab = 0x7ff3dca146c0, hbits_i = 13, hmask_i = 8191, hmask_t = 63, mpool = 0x7ff3dca33240, actv_list = {
    head = 0x7ff3ec97c9f8, tail = 0x7ff3ed9cdec0, num = 7959}, actv_lock = {locked = 0}, aging_timer = {t = {expire = 470560028513268, sl_next = {0x7ff3dce00520, 0x0, 0x7ff3c8800260, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, status = {{state = 1, owner = 0}, 
        u32 = 1}, period = 33900000, f = 0x7ff7f84666b0 &lt;ct_scan_cndb_timer_fun&gt;, arg = 0x0}, callback = 0x7ff7f84666b0 &lt;ct_scan_cndb_timer_fun&gt;, flags = 0}, aging_off = 0, new_off = 0, purge_on = 0, esn = 0, excp_pkts = 1772, tcp_ccn = {cnt = 7928}, 
  udp_ccn = {cnt = 21}, icmp_ccn = {cnt = 10}, rawip_ccn = {cnt = 0}, counter = {4402788, 0 &lt;repeats 99 times&gt;}}
</code></pre><p>添加 rte_timer_reset():<br>
通过 timer_add().timer_get_prev_entries() 比较 expire 找到前一个 tim ，<br>
计算 待插入 tim 的 级数，<br>
根据 级数 插入到前一个 tim 之后，</p>
<p>检查超时 rte_timer_manage():<br>
根据 cur_time 通过 timer_get_prev_entries() 找到 最后一个超时的 tim ，<br>
随后根据刚刚找到的 tim 将 skip list 分为两部分，<br>
将前部分先从 skip list 中删除，随后遍历前半部分(run_first_tim)所有的 tim ，执行 tim 对应 callback ，<br>
如果是 PERIODICAL 类型，再次通过 __rte_timer_reset() 插入到 对应的 skip list 中，</p>
<h2 id="相关结构">相关结构，</h2>
<p>priv_timer[lcore_id].running_tim 为正在执行回调的函数，<br>
__rte_timer_manage() 里可以看到，<br>
可以通过下面查看 (timer_data_id == 0 &amp;&amp; lcore_id == 0) 对应的 skip list 中正在运行的 tim ，</p>
<pre tabindex="0"><code>(gdb) p rte_timer_data_arr[0].priv_timer[0]  
$16 = {pending_head = {expire = 280557093315816, sl_next = {0x7f3e28e074a0, 0x7f3e14affec8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, status = {{state = 0, owner = 0}, u32 = 0}, period = 0, f = 0x0, arg = 0x0}, list_lock = {locked = 1}, updated = 0, 
  curr_skiplist_depth = 2, prev_lcore = 0, running_tim = 0x7f3e104be578}
(gdb) p *(struct rte_timer *)0x7f3e104be578
$17 = {expire = 280557261604410, sl_next = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, status = {{state = 3, owner = 0}, u32 = 3}, period = 169500000, f = 0x7f42438adb30 &lt;bwip_expire_timer_fun&gt;, arg = 0x0}
</code></pre></section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://eiempleo.github.io/posts/rte_timer_subsystem_init-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%8B%E7%BB%8D/"><span>←</span><span>rte_timer_subsystem_init 初始化介绍</span></a>
     
    <a class="next" href="https://eiempleo.github.io/posts/vpp-bitmap/"><span>vpp bitmap 介绍</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://eiempleo.github.io/">Mercury</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
