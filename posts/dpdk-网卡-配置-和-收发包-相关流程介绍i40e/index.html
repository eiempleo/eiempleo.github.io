<!DOCTYPE html>











<html lang="en-us">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>dpdk 网卡 配置 和 收发包 相关流程介绍（i40e） - Mercury</title>

  
  
  <meta name="description" content="参考 https://www.cnblogs.com/yhp-smarthome/p/6705638.html
关于 eth dev ops ， ixgbe 为 ixgbe_eth_dev_ops ， i40e 为 i40e_eth_dev_ops ，
eth_dev-&gt;dev_ops 在 probe 时赋值的，
eth_i40e_pci_probe().eth_i40e_dev_init()
dev-&gt;dev_ops = &amp;i40e_eth_dev_ops;
cn10k_pci_nix().probe
&ndash;&gt; cn10k_nix_probe().cnxk_nix_probe().cnxk_eth_dev_init()
eth_dev-&gt;dev_ops = &amp;cnxk_eth_dev_ops;
配置 网卡 的流程 通常配置网卡设备信息由如下几步组成:
(1) 创建一个 mbuf pool:
mbuf pool 主要是给网卡接收数据包提供 mbuf 的，网卡收到数据需要把数据包通过 DMA 传送到这个 mbuf pool 中的内存中，
testpmd 使用 mbuf_pool_create() 的 rte_pktmbuf_pool_create() 创建的 mbuf 内存池，
vpp 使用 vlib_buffer_main_init() 和 dpdk_buffer_pool_init() 创建的 mbuf 内存池，
(2) rte_eth_dev_configure(): 配置队列的个数，以及接口的配置信息，
进行一些基础的设置，(如 mtu 、 队列数量， rss 相关， 细节没看)" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://eiempleo.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://eiempleo.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://eiempleo.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://eiempleo.github.io/theme.png" />

  

  
  <link rel="icon" href="https://eiempleo.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://eiempleo.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.99.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="dpdk 网卡 配置 和 收发包 相关流程介绍（i40e）" />
<meta property="og:description" content="参考 https://www.cnblogs.com/yhp-smarthome/p/6705638.html
关于 eth dev ops ， ixgbe 为 ixgbe_eth_dev_ops ， i40e 为 i40e_eth_dev_ops ，
eth_dev-&gt;dev_ops 在 probe 时赋值的，
eth_i40e_pci_probe().eth_i40e_dev_init()
dev-&gt;dev_ops = &amp;i40e_eth_dev_ops;
cn10k_pci_nix().probe
&ndash;&gt; cn10k_nix_probe().cnxk_nix_probe().cnxk_eth_dev_init()
eth_dev-&gt;dev_ops = &amp;cnxk_eth_dev_ops;
配置 网卡 的流程 通常配置网卡设备信息由如下几步组成:
(1) 创建一个 mbuf pool:
mbuf pool 主要是给网卡接收数据包提供 mbuf 的，网卡收到数据需要把数据包通过 DMA 传送到这个 mbuf pool 中的内存中，
testpmd 使用 mbuf_pool_create() 的 rte_pktmbuf_pool_create() 创建的 mbuf 内存池，
vpp 使用 vlib_buffer_main_init() 和 dpdk_buffer_pool_init() 创建的 mbuf 内存池，
(2) rte_eth_dev_configure(): 配置队列的个数，以及接口的配置信息，
进行一些基础的设置，(如 mtu 、 队列数量， rss 相关， 细节没看)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eiempleo.github.io/posts/dpdk-%E7%BD%91%E5%8D%A1-%E9%85%8D%E7%BD%AE-%E5%92%8C-%E6%94%B6%E5%8F%91%E5%8C%85-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8Di40e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-07T09:00:00+08:00" />
<meta property="article:modified_time" content="2022-03-07T09:00:00+08:00" />


  
  <meta itemprop="name" content="dpdk 网卡 配置 和 收发包 相关流程介绍（i40e）">
<meta itemprop="description" content="参考 https://www.cnblogs.com/yhp-smarthome/p/6705638.html
关于 eth dev ops ， ixgbe 为 ixgbe_eth_dev_ops ， i40e 为 i40e_eth_dev_ops ，
eth_dev-&gt;dev_ops 在 probe 时赋值的，
eth_i40e_pci_probe().eth_i40e_dev_init()
dev-&gt;dev_ops = &amp;i40e_eth_dev_ops;
cn10k_pci_nix().probe
&ndash;&gt; cn10k_nix_probe().cnxk_nix_probe().cnxk_eth_dev_init()
eth_dev-&gt;dev_ops = &amp;cnxk_eth_dev_ops;
配置 网卡 的流程 通常配置网卡设备信息由如下几步组成:
(1) 创建一个 mbuf pool:
mbuf pool 主要是给网卡接收数据包提供 mbuf 的，网卡收到数据需要把数据包通过 DMA 传送到这个 mbuf pool 中的内存中，
testpmd 使用 mbuf_pool_create() 的 rte_pktmbuf_pool_create() 创建的 mbuf 内存池，
vpp 使用 vlib_buffer_main_init() 和 dpdk_buffer_pool_init() 创建的 mbuf 内存池，
(2) rte_eth_dev_configure(): 配置队列的个数，以及接口的配置信息，
进行一些基础的设置，(如 mtu 、 队列数量， rss 相关， 细节没看)"><meta itemprop="datePublished" content="2022-03-07T09:00:00+08:00" />
<meta itemprop="dateModified" content="2022-03-07T09:00:00+08:00" />
<meta itemprop="wordCount" content="1252">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="dpdk 网卡 配置 和 收发包 相关流程介绍（i40e）"/>
<meta name="twitter:description" content="参考 https://www.cnblogs.com/yhp-smarthome/p/6705638.html
关于 eth dev ops ， ixgbe 为 ixgbe_eth_dev_ops ， i40e 为 i40e_eth_dev_ops ，
eth_dev-&gt;dev_ops 在 probe 时赋值的，
eth_i40e_pci_probe().eth_i40e_dev_init()
dev-&gt;dev_ops = &amp;i40e_eth_dev_ops;
cn10k_pci_nix().probe
&ndash;&gt; cn10k_nix_probe().cnxk_nix_probe().cnxk_eth_dev_init()
eth_dev-&gt;dev_ops = &amp;cnxk_eth_dev_ops;
配置 网卡 的流程 通常配置网卡设备信息由如下几步组成:
(1) 创建一个 mbuf pool:
mbuf pool 主要是给网卡接收数据包提供 mbuf 的，网卡收到数据需要把数据包通过 DMA 传送到这个 mbuf pool 中的内存中，
testpmd 使用 mbuf_pool_create() 的 rte_pktmbuf_pool_create() 创建的 mbuf 内存池，
vpp 使用 vlib_buffer_main_init() 和 dpdk_buffer_pool_init() 创建的 mbuf 内存池，
(2) rte_eth_dev_configure(): 配置队列的个数，以及接口的配置信息，
进行一些基础的设置，(如 mtu 、 队列数量， rss 相关， 细节没看)"/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://eiempleo.github.io/">Mercury</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>Mar 7, 2022</time>
      
      
    </p>
    <h1>dpdk 网卡 配置 和 收发包 相关流程介绍（i40e）</h1>
  </header>
  <section class="post-content"><p>参考 <a href="https://www.cnblogs.com/yhp-smarthome/p/6705638.html">https://www.cnblogs.com/yhp-smarthome/p/6705638.html</a></p>
<h2 id="关于-eth-dev-ops-">关于 eth dev ops ，</h2>
<p>ixgbe 为 ixgbe_eth_dev_ops ，
i40e 为 i40e_eth_dev_ops ，</p>
<p>eth_dev-&gt;dev_ops 在 probe 时赋值的，<br>
  eth_i40e_pci_probe().eth_i40e_dev_init()<br>
    dev-&gt;dev_ops = &amp;i40e_eth_dev_ops;<br>
  cn10k_pci_nix().probe<br>
  &ndash;&gt; cn10k_nix_probe().cnxk_nix_probe().cnxk_eth_dev_init()<br>
    eth_dev-&gt;dev_ops = &amp;cnxk_eth_dev_ops;</p>
<h2 id="配置-网卡-的流程">配置 网卡 的流程</h2>
<p>通常配置网卡设备信息由如下几步组成:</p>
<p>(1) 创建一个 mbuf pool:<br>
  mbuf pool 主要是给网卡接收数据包提供 mbuf 的，网卡收到数据需要把数据包通过 DMA 传送到这个 mbuf pool 中的内存中，<br>
    testpmd 使用 mbuf_pool_create() 的 rte_pktmbuf_pool_create() 创建的 mbuf 内存池，<br>
    vpp 使用 vlib_buffer_main_init() 和 dpdk_buffer_pool_init() 创建的 mbuf 内存池，</p>
<p>(2) rte_eth_dev_configure(): 配置队列的个数，以及接口的配置信息，<br>
  进行一些基础的设置，(如 mtu 、 队列数量， rss 相关， 细节没看)<br>
  执行 dev-&gt;dev_ops-&gt;dev_configure 回调，<br>
    i40e 的为 i40e_dev_configure() ，<br>
    cnxk 的好像没有该回调，</p>
<p>(3) rte_eth_rx_queue_setup(): 初始化接收队列(每个接收队列调用一次)<br>
  进行一些基础配置，<br>
  执行 rx_queue_setup 回调，<br>
    (*dev-&gt;dev_ops-&gt;rx_queue_setup)(dev, rx_queue_id, nb_rx_desc, socket_id, &amp;local_conf, mp);<br>
    对于 i40e: i40e_dev_rx_queue_setup()<br>
      分配 rxq :<br>
        通过 rte_zmalloc_socket() 分配，长度为 sizeof(struct i40e_rx_queue)<br>
        该结构保存很多 rx queue 的信息， 如指向的 mempool ， rx desc 数量，<br>
      分配 rxq-&gt;rx_ring:<br>
        通过 rte_eth_dma_zone_reserve() 分配，<br>
        长度为 sizeof(union i40e_rx_desc) * (I40E_MAX_RING_DESC + RTE_PMD_I40E_RX_MAX_BURST) ，<br>
        这些是 网卡的 rx desc ring ， 用于收包时 dma 和 pmd 交互，<br>
      分配 rxq-&gt;sw_ring:<br>
        通过 rte_zmalloc_socket() 分配，长度为 sizeof(struct i40e_rx_entry) * (nb_desc + RTE_PMD_I40E_RX_MAX_BURST)<br>
        i40e_rx_entry 暂时只有一个 mbuf 指针，<br>
        相当于一个 mbuf 指针 数组，此时还没建立起 mbuf 和 mempool 的关联，</p>
<p>(4) rte_eth_tx_queue_setup(): 初始化发送队列(每个发送队列调用一次)<br>
  进行一些基础配置，<br>
  执行 tx_queue_setup 回调，<br>
    (*dev-&gt;dev_ops-&gt;tx_queue_setup)(dev, tx_queue_id, nb_tx_desc, socket_id, &amp;local_conf);<br>
    对于 i40e: i40e_dev_tx_queue_setup()<br>
      分配 txq :<br>
        通过 rte_zmalloc_socket() 分配，长度为 sizeof(struct i40e_tx_queue)<br>
        该结构保存很多 tx queue 的信息， 如指向的 tx desc 数量，<br>
      分配 txq-&gt;mz:<br>
        通过 rte_eth_dma_zone_reserve() 分配，<br>
        长度为 sizeof(struct i40e_tx_desc) * I40E_MAX_RING_DESC ，<br>
        这些是 网卡的 tx desc ring ， 用于收包时 dma 和 pmd 交互，<br>
      分配 txq-&gt;sw_ring:<br>
        通过 rte_zmalloc_socket() 分配，长度为 sizeof(struct i40e_tx_entry) * nb_desc<br>
        i40e_tx_entry 包含一个 mbuf 指针，</p>
<p>(5) rte_eth_dev_start(): 启动设备<br>
  到这里为止， i40e_dev_rx_queue_setup() 和 i40e_dev_tx_queue_setup() 分配的数据结构<br>
  rxq-&gt;rx_ring 、 rxq-&gt;sw_ring 、 txq-&gt;mz 、 txq-&gt;sw_ring 和 mbuf pool 、 dma 暂时还没有关联起来，<br>
  这里进行设置，<br>
  主要会调用 dev_start 回调，<br>
    (*dev-&gt;dev_ops-&gt;dev_start)(dev);<br>
    对于 i40e ， 为 i40e_dev_start() ，会进行如下流程，<br>
      i40e_dev_rxtx_init().i40e_dev_tx_init()<br>
        .i40e_tx_queue_init(): 设置每个队列，每个队列调用一次，<br>
        通过 i40e_set_lan_tx_queue_context() 将该 queue 对应的 i40e_hmc_txq_ce_info<br>
          设置到 网卡 寄存器里， 通过 Transmit Queue Context 和 host 共享，<br>
        tx_ctx.base 为 tx desc ring 起始物理地址，<br>
        tx_ctx.qlen 为 tx desc 数量，<br>
        各个字段可以在 8.4.3.4.2 Transmit Queue Context in FPM 里找到，<br>
        这里记录了网卡 tx desc ring 的 tail ，后面发包时会更新，<br>
        txq-&gt;qtx_tail = hw-&gt;hw_addr + I40E_QTX_TAIL(pf_q);<br>
        .i40e_set_tx_function() 设置接收回调函数，<br>
      i40e_dev_rxtx_init().i40e_dev_rx_init()<br>
        .i40e_pf_config_rss() 设置 rss 到 网卡寄存器，<br>
        .i40e_rx_queue_init() 设置每个队列，每个队列调用一次，<br>
        通过 i40e_set_lan_rx_queue_context() 将该 queue 对应的 i40e_hmc_rxq_ce_info<br>
        设置到 网卡 寄存器里， 通过 Receive Queue Context 和 host 共享，<br>
        各个字段可以在 8.3.3.2.2 Receive Queue Context in FPM 里找到，<br>
        这里记录了网卡 rx desc ring 的 tail ，后面收包时会更新，<br>
        rxq-&gt;qrx_tail = hw-&gt;hw_addr + I40E_QRX_TAIL(pf_q);<br>
        .i40e_set_tx_function() 设置发送回调函数，<br>
      i40e_dev_rx_queue_start()<br>
        i40e_alloc_rx_queue_mbufs()<br>
          从 mbuf 所在的 mempool 里分配 mbuf ， 用来填充 rxq-&gt;sw_ring 和 rxq-&gt;rx_ring<br>
          这里 rxq-&gt;sw_ring 和 rxq-&gt;rx_ring 是一一对应的， rxq-&gt;rx_ring[i] 对应 rxq-&gt;sw_ring[i] ，<br>
          rxd-&gt;read.pkt_addr 保存 mbuf 的 iova 地址，这样接收时， dma 就会将数据包 写入到 rx desc 指向的 mbuf 中，<br>
        初始化 rx desc tail register ，此时 tail 为末尾， 所有的 rx desc 都可以供 网卡写入 报文，<br>
          I40E_PCI_REG_WRITE(rxq-&gt;qrx_tail, rxq-&gt;nb_rx_desc - 1);
          x710 8.3.3.1.1 Receive Queue Enable Flow 有下面介绍，<br>
          Clear the Tail pointer in the QRX_TAIL[n] register<br>
          and then set the Tail pointer to the end of the descriptor ring (&rsquo;n&rsquo; is the queue index within the PF space)<br>
        i40e_switch_rx_queue(): 使能 rx queue ，<br>
          Set the QENA_REQ flag in the QRX_ENA[n] register<br>
          BAR0 Registers Summary 可以看到 QRX_ENA[Q] Global Receive Queue Enable<br>
      i40e_dev_tx_queue_start()<br>
        i40e_switch_tx_queue():<br>
          将 tx desc ring 的 head 设置为 0 ，<br>
          I40E_WRITE_REG(hw, I40E_QTX_HEAD(q_idx), 0);<br>
          使能 tx queue ，I40E_QTX_ENA(q_idx) ，<br>
            BAR0 Registers Summary 可以看到 QTX_ENA[Q] Global Transmit Queue Enable</p>
<h2 id="网卡收发包">网卡收发包，</h2>
<h3 id="收包流程">收包流程，</h3>
<p>网卡收到报文后会先查看 rx desc ring head 的位置(根据下面的描述，这里或许也是查看 dd 标志，具体不清楚，暂未验证，)，<br>
将报文 dma 到 rx desc ring head 对应 rx desc 指向的 mbuf 里，<br>
随后 更新 rx desc ring head 的位置， 更新刚写入 rx desc 的 dd 标志，</p>
<p>dpdk 收包入口为 rte_eth_rx_burst()<br>
每种 pmd 收包回调一般都有很多种，<br>
对于 i40e ， 暂时查看最简单的 i40e_recv_pkts() ，大概流程如下，<br>
从 rx desc ring 的 tail 开始读取，取出里面的 mbuf ，<br>
    这个 tail 是 rxq-&gt;rx_tail ， 和 rx desc ring tail 寄存器的值不一定一致，<br>
    因为可能读取后，并没有更新寄存器，<br>
    读取的结束位置一方面根据传入的参数判断， 另一方面根据 dd 标志(I40E_RX_DESC_STATUS_DD_SHIFT)判断，<br>
        这里没有读取 rx desc ring 的 head(可能读取较慢，) ， 而是根据 dd 标志判断 rx desc ring 的 head 的位置，<br>
    通过 rxdp-&gt;read.hdr_addr = 0; 将 dd 标志置 0 ，<br>
当接收量大于 rxq-&gt;rx_free_thresh 阈值时，更新 rx desc ring tail 寄存器，<br>
    可能更新操作较慢，减少更新次数，</p>
<h3 id="关于收包的-dd-标志">关于收包的 dd 标志，</h3>
<p>dd 标志 标识 一个描述符的可用情况，<br>
网卡在使用这个描述符前，先检查 DD位 是否为0，<br>
    如果为 0 ，那么就可以使用描述符，把数据拷贝到描述符指定的地址，之后把 DD标志 位置为1，否则表示不能使用这个描述符，<br>
而对于驱动而言，恰恰相反，在读取数据包时，先检查DD位是否为1，<br>
    如果为 1 ，表示网卡已经把数据放到了内存中，可以读取，读取完后，再把 DD位 设置为0，否则，就表示没有数据包可读，</p>
<h3 id="receive-descriptor---read-format-和-receive-descriptor---write-back-format">Receive Descriptor - Read Format 和 Receive Descriptor - Write Back Format</h3>
<p>rxdp-&gt;wb 的数据由 网卡写入 ， 驱动来处理 ，<br>
    i40e 的 8.3.3.1.4.2 Receive descriptor reporting (descriptor write back) 里可以看到，<br>
    i40e_recv_pkts() 的处理也符合 datasheet 里的描述，<br>
rxdp-&gt;read 由 驱动写入 ， 网卡来处理 ，</p>
<h3 id="关于收包时的中断">关于收包时的中断，</h3>
<p>dpdk 网卡收包时， 在描述符回写完成后没有触发中断， pmd 通过 polling 的模式直接收包，<br>
？？？ 具体怎么屏蔽的中断还没看太清楚，</p>
<p>对于 i40e ，<br>
i40e 的 8.3.3.1.4.2 Receive descriptor reporting (descriptor write back) 可以看到，<br>
Most applications use interrupts to invoke the software device driver.<br>
In some applications, the X710/XXV710/XL710 is activated in polling mode (with no interrupts)</p>
<h2 id="发包">发包，</h2>
<p>发包接口为 rte_eth_tx_burst()<br>
调用发包回调，<br>
对于 i40e ， 查看最简单的 i40e_xmit_pkts() ，大概流程如下，<br>
将报文写入到 tx desc 中，<br>
在 txq-&gt;nb_tx_used &gt;= txq-&gt;tx_rs_thresh 时给 tx desc 设置 rs ，nic hardware 后面处理到这个 tx desc 时会 write back ，<br>
更新 tx desc ring 的 tail 寄存器，<br>
    I40E_PCI_REG_WC_WRITE_RELAXED(txq-&gt;qtx_tail, tx_id);<br>
nic hardware 从 tx desc ring head 处开始处理 desc 进行发送，</p>
<h3 id="关于-tx-desc">关于 tx desc</h3>
<p>Transmit Data Descriptor 和 Transmit Context Descriptor 是 dpdk pmd driver 写入， nic hardware 读取，<br>
    当报文较长时，会分散到多个 Transmit Data Descriptor 中， 最后一个 tx desc 设置 I40E_TX_DESC_CMD_EOP 标识，<br>
        一个 tx descriptor 最多能存放 I40E_MAX_DATA_PER_TXD(16k - 1 Bytes)<br>
    有些 tx offload 需要额外的 tx desc(Transmit Context Descriptor) ，<br>
    下面是 i40e_xmit_pkts() 中的一些注释，<br>
    The number of descriptors that must be allocated for<br>
    a packet equals to the number of the segments of that<br>
    packet plus 1 context descriptor if needed.<br>
    Recalculate the needed tx descs when TSO enabled in case<br>
    the mbuf data size exceeds max data size that hw allows<br>
    per tx desc.</p>
<h3 id="关于-write-back-">关于 write back ，</h3>
<p>接收时，回写是立即执行的，也就是 hardware 收到包， dma 完成， 更新 rx desc 后， pmd driver 就可以 polling 到 write back rx desc ，<br>
发送时，回写不是立即执行的，主要是通过 RS bit ，<br>
    pmd driver 发包时 在需要回写位置的 Transmit Data Descriptor 中设置 RS bit ，<br>
    hardware 发送时，如果遇到了设置 RS bit 的 Transmit Data Descriptor ， 则进行回写，</p>
<p>i40e 的 8.4.3.1.5 Software Fast Path Programming 中有介绍，<br>
The hardware reports completed descriptors only for those ones indicated by an &lsquo;RS&rsquo; bit in the CMD<br>
field in the descriptor.</p>
<p>下面链接解释了回写不是立即执行的原因，<br>
大概主要是为了 减少 Tx descriptors 相关的 Inbound Write Bandwidth ，<br>
还讲了为什么接收时描述符需要立即回写， 主要是为了尽快收包，<br>
发包时对回写时间没那么紧急，可以一些包回写一次，减少回写的数量，<br>
<a href="https://www.intel.com/content/www/us/en/develop/documentation/vtune-cookbook/top/methodologies/pcie-traffic-in-dpdk-apps.html">https://www.intel.com/content/www/us/en/develop/documentation/vtune-cookbook/top/methodologies/pcie-traffic-in-dpdk-apps.html</a><br>
Decreased Inbound Write Bandwidth related to the Tx descriptors.<br>
Tx descriptor write back is required to notify the core where the Tx queue head is and which Tx descriptors can be reused. In case of packet receiving, it is critical to write back each Rx descriptor to notify the core about a new arrived packet as soon as possible. In packet transmitting, there is no need to write back each Tx descriptor. It is sufficient to notify the core about successful packet transmission periodically (for example, on every 32nd packet), which would mean that all previous packets are transmitted successfully too. The NIC writes back the Tx descriptor when the RS (Report Status) bit of the Tx descriptor is set. On the DPDK side, there is a RS bit threshold; its value defines how frequently the RS bit is set and thus how frequently the NIC writes back Tx descriptors. This optimization amortizes Inbound Writes related to the Tx descriptors.</p>
<h2 id="dma-相关">dma 相关，</h2>
<p>dma 通过 rx desc 、 tx desc 和 dpdk pmd driver 交互，<br>
    x710 文档 8.3 LAN receive data path 可以看到 rx desc 的介绍和各种结构，<br>
    x710 文档 8.4 LAN Transmit Data-Path 可以看到 tx desc 的介绍和各种结构，</p>
<h3 id="关于-rte_eth_dma_zone_reserve">关于 rte_eth_dma_zone_reserve()</h3>
<p>分配 rx desc 和 tx desc ，<br>
    需要通过 eth_dev_dma_mzone_name() 设置 一个 memzone 使用的 name ， 返回的是下面这种，<br>
        eth_p0_q0_rx_ring(port 0/queue 0 rx desc ring) 、 eth_p0_q0_tx_ring(port 0/queue 0 tx desc ring) 、<br>
        eth_p1_q0_rx_ring(port 1/queue 0 rx desc ring) 、 eth_p1_q0_tx_ring(port 1/queue 0 tx desc ring) 、<br>
    通过 rte_memzone_reserve_aligned() 分配实际内存，<br>
        rte_memzone_reserve_aligned(z_name, size, socket_id, RTE_MEMZONE_IOVA_CONTIG, align);<br>
        dma 的地址 需要保证 iova 地址连续，<br>
        对于 igb_uio 驱动， 意味着需要物理地址连续，(此时 iova 地址为物理地址，与虚拟地址不同)<br>
        (？？？ 猜测)对于 vfio-pci 驱动， 只需要虚拟地址连续， iommu 会进行转换，此时无需物理地址连续，<br>
        此时 iova 地址和虚拟地址是同一个，<br>
        对于 x710 ， 一个 rx desc 大小差不多为 16字节 或 32字节 ， 一个 hugepage 最少为 2M ，可以存储 65536 个物理地址连续的 rx desc ，<br>
        (gdb) p sizeof(union i40e_32byte_rx_desc)<br>
        $1 = 32</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://eiempleo.github.io/posts/dpdk-%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8Bi40e/"><span>←</span><span>dpdk 网卡中断处理流程(i40e)</span></a>
     
    <a class="next" href="https://eiempleo.github.io/posts/rte_timer_subsystem_init-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%8B%E7%BB%8D/"><span>rte_timer_subsystem_init 初始化介绍</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://eiempleo.github.io/">Mercury</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
